/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SplathonAPI
 * Splathonで使うAPI
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://splathon-api-us.appspot.com/splathon/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * バトル。勝敗などは決まってない状態のこともある。
 * @export
 * @interface Battle
 */
export interface Battle {
    /**
     * Battle ID
     * @type {number}
     * @memberof Battle
     */
    id?: number;
    /**
     * 勝者がどちらか。
     * @type {string}
     * @memberof Battle
     */
    winner?: Battle.WinnerEnum;
    /**
     * 何戦目か
     * @type {number}
     * @memberof Battle
     */
    order: number;
    /**
     * 
     * @type {Rule}
     * @memberof Battle
     */
    rule?: Rule;
    /**
     * 
     * @type {Stage}
     * @memberof Battle
     */
    stage?: Stage;
}

/**
 * @export
 * @namespace Battle
 */
export namespace Battle {
    /**
     * @export
     * @enum {string}
     */
    export enum WinnerEnum {
        Alpha = <any> 'alpha',
        Bravo = <any> 'bravo'
    }
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    numbering: number;
    /**
     * 
     * @type {Array<Rule>}
     * @memberof Event
     */
    rules?: Array<Rule>;
    /**
     * 
     * @type {Array<Stage>}
     * @memberof Event
     */
    stages?: Array<Stage>;
}

/**
 * 
 * @export
 * @interface GetNextMatchResponse
 */
export interface GetNextMatchResponse {
    /**
     * 次のマッチがない、または決まってない場合nullになる。
     * @type {NextMatch}
     * @memberof GetNextMatchResponse
     */
    nextMatch?: NextMatch;
}

/**
 * 
 * @export
 * @interface ListNoticesResponse
 */
export interface ListNoticesResponse {
    /**
     * List of notices ordered by reverse chronological order.
     * @type {Array<Notice>}
     * @memberof ListNoticesResponse
     */
    notices?: Array<Notice>;
}

/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * Slack username (https://splathon.slack.com/account/settings#username)
     * @type {string}
     * @memberof LoginRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
}

/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * Session API token. Send this token via X-SPLATHON-API-TOKEN HTTP hader. 'X-SPLATHON-API-TOKEN: <token>'
     * @type {string}
     * @memberof LoginResponse
     */
    token: string;
    /**
     * 管理者かどうか。(e.g. true なら battle data を送信できる。)
     * @type {boolean}
     * @memberof LoginResponse
     */
    isAdmin: boolean;
    /**
     * 所属チーム。観戦だとないこともある。またloginユーザーはSlack アカウントを共有している複数の参加者と紐ずいていることもあるが、所属チームは必ず1つ以下。
     * @type {Team}
     * @memberof LoginResponse
     */
    team?: Team;
}

/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * Match ID
     * @type {number}
     * @memberof Match
     */
    id: number;
    /**
     * 勝者がどちらか。または引き分け。
     * @type {string}
     * @memberof Match
     */
    winner?: Match.WinnerEnum;
    /**
     * Room内でのマッチの順番
     * @type {number}
     * @memberof Match
     */
    order?: number;
    /**
     * 
     * @type {Team}
     * @memberof Match
     */
    teamAlpha: Team;
    /**
     * 
     * @type {Team}
     * @memberof Match
     */
    teamBravo: Team;
    /**
     * 
     * @type {Array<Battle>}
     * @memberof Match
     */
    battles?: Array<Battle>;
    /**
     * ラウンド名。e.g. 予選第1ラウンド, 決勝T1回戦, 決勝戦. Match APIから読んだときに埋まっている
     * @type {string}
     * @memberof Match
     */
    roundName?: string;
}

/**
 * @export
 * @namespace Match
 */
export namespace Match {
    /**
     * @export
     * @enum {string}
     */
    export enum WinnerEnum {
        Alpha = <any> 'alpha',
        Bravo = <any> 'bravo',
        Draw = <any> 'draw'
    }
}

/**
 * チーム一覧表示などのAPIではdetailが埋まってることもある
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * Member ID (Slack ID かも?)
     * @type {number}
     * @memberof Member
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    name: string;
    /**
     * Slack icon URL
     * @type {string}
     * @memberof Member
     */
    icon?: string;
    /**
     * 
     * @type {MemberDetail}
     * @memberof Member
     */
    detail?: MemberDetail;
}

/**
 * 
 * @export
 * @interface MemberDetail
 */
export interface MemberDetail {
    /**
     * 一言コメント
     * @type {string}
     * @memberof MemberDetail
     */
    shortComment?: string;
    /**
     * A+, X (2401~2500)
     * @type {string}
     * @memberof MemberDetail
     */
    rankSplatZones?: string;
    /**
     * A+, X (2401~2500)
     * @type {string}
     * @memberof MemberDetail
     */
    rankTowerControl?: string;
    /**
     * A+, X (2401~2500)
     * @type {string}
     * @memberof MemberDetail
     */
    rankRainmaker?: string;
    /**
     * A+, X (2401~2500)
     * @type {string}
     * @memberof MemberDetail
     */
    rankClamBlitz?: string;
    /**
     * メインウェポン/好きなブキ
     * @type {string}
     * @memberof MemberDetail
     */
    mainWeapon?: string;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
}

/**
 * 
 * @export
 * @interface NextMatch
 */
export interface NextMatch {
    /**
     * 
     * @type {Team}
     * @memberof NextMatch
     */
    ownTeam?: Team;
    /**
     * 
     * @type {Team}
     * @memberof NextMatch
     */
    opponentTeam?: Team;
    /**
     * ラウンド名。e.g. 予選第1ラウンド, 決勝T1回戦, 決勝戦.
     * @type {string}
     * @memberof NextMatch
     */
    roundName?: string;
    /**
     * 
     * @type {NextMatchRoom}
     * @memberof NextMatch
     */
    room?: NextMatchRoom;
    /**
     * Room内でのマッチの順番
     * @type {number}
     * @memberof NextMatch
     */
    matchOrderInRoom?: number;
    /**
     * 
     * @type {Match}
     * @memberof NextMatch
     */
    matchDetail?: Match;
}

/**
 * 
 * @export
 * @interface NextMatchRoom
 */
export interface NextMatchRoom {
    /**
     * Room ID.
     * @type {number}
     * @memberof NextMatchRoom
     */
    id?: number;
    /**
     * Room name. e.g. A卓
     * @type {string}
     * @memberof NextMatchRoom
     */
    name: string;
}

/**
 * 
 * @export
 * @interface Notice
 */
export interface Notice {
    /**
     * 
     * @type {string}
     * @memberof Notice
     */
    text: string;
    /**
     * 
     * @type {number}
     * @memberof Notice
     */
    timestampSec: number;
}

/**
 * 
 * @export
 * @interface ParticipantReception
 */
export interface ParticipantReception {
    /**
     * ハンドルネーム。 e.g. みーくん
     * @type {string}
     * @memberof ParticipantReception
     */
    nickname: string;
    /**
     * カタカナのフルネーム。 e.g. ヤマダタロウ
     * @type {string}
     * @memberof ParticipantReception
     */
    fullnameKana: string;
    /**
     * 所属企業名
     * @type {string}
     * @memberof ParticipantReception
     */
    companyName: string;
    /**
     * チーム名
     * @type {string}
     * @memberof ParticipantReception
     */
    teamName?: string;
    /**
     * チームID(一応)
     * @type {number}
     * @memberof ParticipantReception
     */
    teamId?: number;
    /**
     * 合計参加費(円)
     * @type {number}
     * @memberof ParticipantReception
     */
    participantFee: number;
    /**
     * 懇親会に参加するか否か
     * @type {boolean}
     * @memberof ParticipantReception
     */
    joinParty: boolean;
    /**
     * スタッフかどうか
     * @type {boolean}
     * @memberof ParticipantReception
     */
    isStaff: boolean;
    /**
     * playerとして参加するかどうか。falseならスタッフか観戦
     * @type {boolean}
     * @memberof ParticipantReception
     */
    isPlayer: boolean;
    /**
     * Nintendo Switch doc を持ってきたか
     * @type {boolean}
     * @memberof ParticipantReception
     */
    hasSwitchDock: boolean;
    /**
     * 同伴者がいるかどうか。いる場合は用スプレッドシート確認。
     * @type {boolean}
     * @memberof ParticipantReception
     */
    hasCompanion: boolean;
}

/**
 * 
 * @export
 * @interface Rank
 */
export interface Rank {
    /**
     * 順位
     * @type {number}
     * @memberof Rank
     */
    rank: number;
    /**
     * member も fill される
     * @type {Team}
     * @memberof Rank
     */
    team: Team;
    /**
     * 勝ち点
     * @type {number}
     * @memberof Rank
     */
    point: number;
    /**
     * OMWP (Opponent Match Win Percentage)
     * @type {number}
     * @memberof Rank
     */
    omwp?: number;
    /**
     * 何戦こなしたか。
     * @type {number}
     * @memberof Rank
     */
    numOfMatches?: number;
}

/**
 * 予選ランキング
 * @export
 * @interface Ranking
 */
export interface Ranking {
    /**
     * ランキング計算時点の説明。e.g. 予選第2ラウンド終了時
     * @type {string}
     * @memberof Ranking
     */
    rankTime?: string;
    /**
     * 
     * @type {Array<Rank>}
     * @memberof Ranking
     */
    rankings?: Array<Rank>;
}

/**
 * ビル入館情報/Splathon会場受付情報
 * @export
 * @interface ReceptionCode
 */
export interface ReceptionCode {
    /**
     * Splathon会場入場コード/XXXビル入館コード
     * @type {string}
     * @memberof ReceptionCode
     */
    name?: string;
    /**
     * 入場の説明
     * @type {string}
     * @memberof ReceptionCode
     */
    description?: string;
    /**
     * コードの説明
     * @type {string}
     * @memberof ReceptionCode
     */
    shortText?: string;
    /**
     * Image URL of QR code
     * @type {string}
     * @memberof ReceptionCode
     */
    qrcodeImg?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceptionCode
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceptionCode
     */
    codeType?: ReceptionCode.CodeTypeEnum;
}

/**
 * @export
 * @namespace ReceptionCode
 */
export namespace ReceptionCode {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeTypeEnum {
        Qrcode = <any> 'qrcode',
        Barcode = <any> 'barcode'
    }
}

/**
 * 
 * @export
 * @interface ReceptionPartcipantsDataResponse
 */
export interface ReceptionPartcipantsDataResponse {
    /**
     * 受付の仕方の説明や注意点などのフリーテキスト。
     * @type {string}
     * @memberof ReceptionPartcipantsDataResponse
     */
    description?: string;
    /**
     * 参加者の Slack Internal ID
     * @type {string}
     * @memberof ReceptionPartcipantsDataResponse
     */
    slackInternalId?: string;
    /**
     * 1つのSlackIDで複数の参加者をカバーしている。また participants とは別に参加者情報のない同伴者が存在する可能性があり、 もしいる場合は has_companion flag が true となる
     * @type {Array<ParticipantReception>}
     * @memberof ReceptionPartcipantsDataResponse
     */
    participants?: Array<ParticipantReception>;
}

/**
 * 
 * @export
 * @interface ReceptionResponse
 */
export interface ReceptionResponse {
    /**
     * ビル入館情報
     * @type {ReceptionCode}
     * @memberof ReceptionResponse
     */
    building?: ReceptionCode;
    /**
     * Splathon会場受付情報
     * @type {ReceptionCode}
     * @memberof ReceptionResponse
     */
    splathon?: ReceptionCode;
}

/**
 * 予選/決勝Tのリザルト。予選/決勝Tは同じ構造なのでフラットにできるがクライアントがトーナメント表だせる拡張性持たせるために別フィールドで持つ。
 * @export
 * @interface Results
 */
export interface Results {
    /**
     * 
     * @type {Array<Round>}
     * @memberof Results
     */
    qualifiers?: Array<Round>;
    /**
     * 
     * @type {Array<Round>}
     * @memberof Results
     */
    tournament?: Array<Round>;
}

/**
 * Roomごとのマッチ
 * @export
 * @interface Room
 */
export interface Room {
    /**
     * Room ID.
     * @type {number}
     * @memberof Room
     */
    id?: number;
    /**
     * Room name. e.g. A卓
     * @type {string}
     * @memberof Room
     */
    name: string;
    /**
     * 
     * @type {Array<Match>}
     * @memberof Room
     */
    matches: Array<Match>;
}

/**
 * 予選/決勝Tラウンド両方扱う。
 * @export
 * @interface Round
 */
export interface Round {
    /**
     * ラウンド名。e.g. 予選第1ラウンド, 決勝T1回戦, 決勝戦
     * @type {string}
     * @memberof Round
     */
    name: string;
    /**
     * 何ラウンドか。i.e. 予選第Nラウンド, 決勝T N回戦
     * @type {number}
     * @memberof Round
     */
    round?: number;
    /**
     * 
     * @type {Array<Room>}
     * @memberof Round
     */
    rooms?: Array<Room>;
}

/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * Rule key. ref: https://splatoon2.ink/data/locale/ja.json
     * @type {string}
     * @memberof Rule
     */
    key: Rule.KeyEnum;
    /**
     * Localized rule name.
     * @type {string}
     * @memberof Rule
     */
    name?: string;
}

/**
 * @export
 * @namespace Rule
 */
export namespace Rule {
    /**
     * @export
     * @enum {string}
     */
    export enum KeyEnum {
        TurfWar = <any> 'turf_war',
        SplatZones = <any> 'splat_zones',
        TowerControl = <any> 'tower_control',
        Rainmaker = <any> 'rainmaker',
        ClamBlitz = <any> 'clam_blitz'
    }
}

/**
 * 
 * @export
 * @interface Stage
 */
export interface Stage {
    /**
     * Stage ID. ref: https://splatoon2.ink/data/locale/ja.json
     * @type {number}
     * @memberof Stage
     */
    id: number;
    /**
     * Localized stage name.
     * @type {string}
     * @memberof Stage
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * Team ID
     * @type {number}
     * @memberof Team
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    name: string;
    /**
     * Team の大会にむけての意気込みコメント
     * @type {string}
     * @memberof Team
     */
    shortComment?: string;
    /**
     * 
     * @type {Array<Member>}
     * @memberof Team
     */
    members?: Array<Member>;
}

/**
 * 
 * @export
 * @interface Teams
 */
export interface Teams {
    /**
     * 
     * @type {Array<Team>}
     * @memberof Teams
     */
    teams?: Array<Team>;
}


/**
 * AdminApi - fetch parameter creator
 * @export
 */
export const AdminApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 参加登録API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling completeReception.');
            }
            // verify required parameter 'splathonReceptionCode' is not null or undefined
            if (splathonReceptionCode === null || splathonReceptionCode === undefined) {
                throw new RequiredError('splathonReceptionCode','Required parameter splathonReceptionCode was null or undefined when calling completeReception.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling completeReception.');
            }
            const localVarPath = `/v{eventId}/reception/{splathonReceptionCode}/complete`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"splathonReceptionCode"}}`, encodeURIComponent(String(splathonReceptionCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 参加者情報取得API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getParticipantsDataForReception.');
            }
            // verify required parameter 'splathonReceptionCode' is not null or undefined
            if (splathonReceptionCode === null || splathonReceptionCode === undefined) {
                throw new RequiredError('splathonReceptionCode','Required parameter splathonReceptionCode was null or undefined when calling getParticipantsDataForReception.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling getParticipantsDataForReception.');
            }
            const localVarPath = `/v{eventId}/reception/{splathonReceptionCode}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"splathonReceptionCode"}}`, encodeURIComponent(String(splathonReceptionCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a battle data in the match.
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {Battle} battle 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling updateBattle.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling updateBattle.');
            }
            // verify required parameter 'battle' is not null or undefined
            if (battle === null || battle === undefined) {
                throw new RequiredError('battle','Required parameter battle was null or undefined when calling updateBattle.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling updateBattle.');
            }
            const localVarPath = `/v{eventId}/matches/{matchId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Battle" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(battle || {}) : (battle || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 参加登録API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).completeReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 参加者情報取得API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReceptionPartcipantsDataResponse> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).getParticipantsDataForReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a battle data in the match.
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {Battle} battle 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AdminApiFetchParamCreator(configuration).updateBattle(eventId, matchId, battle, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 参加登録API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
            return AdminApiFp(configuration).completeReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
        /**
         * 参加者情報取得API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
            return AdminApiFp(configuration).getParticipantsDataForReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
        /**
         * Update a battle data in the match.
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {Battle} battle 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options?: any) {
            return AdminApiFp(configuration).updateBattle(eventId, matchId, battle, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 参加登録API
     * @param {number} eventId 
     * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
        return AdminApiFp(this.configuration).completeReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

    /**
     * 参加者情報取得API
     * @param {number} eventId 
     * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
        return AdminApiFp(this.configuration).getParticipantsDataForReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

    /**
     * Update a battle data in the match.
     * @param {number} eventId 
     * @param {number} matchId match id
     * @param {Battle} battle 
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options?: any) {
        return AdminApiFp(this.configuration).updateBattle(eventId, matchId, battle, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return event data
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventId: number, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getEvent.');
            }
            const localVarPath = `/v{eventId}/event`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return detail team data
         * @param {number} eventId 
         * @param {number} teamId team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDetail(eventId: number, teamId: number, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getTeamDetail.');
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling getTeamDetail.');
            }
            const localVarPath = `/v{eventId}/teams/{team_id}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return notices
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotices(eventId: number, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling listNotices.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling listNotices.');
            }
            const localVarPath = `/v{eventId}/notices`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return team list
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(eventId: number, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling listTeams.');
            }
            const localVarPath = `/v{eventId}/teams`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} eventId 
         * @param {LoginRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(eventId: number, request: LoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling login.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling login.');
            }
            const localVarPath = `/v{eventId}/login`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return event data
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getEvent(eventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return detail team data
         * @param {number} eventId 
         * @param {number} teamId team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDetail(eventId: number, teamId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getTeamDetail(eventId, teamId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return notices
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotices(eventId: number, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListNoticesResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listNotices(eventId, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return team list
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(eventId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Teams> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listTeams(eventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} eventId 
         * @param {LoginRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(eventId: number, request: LoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).login(eventId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return event data
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventId: number, options?: any) {
            return DefaultApiFp(configuration).getEvent(eventId, options)(fetch, basePath);
        },
        /**
         * Return detail team data
         * @param {number} eventId 
         * @param {number} teamId team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamDetail(eventId: number, teamId: number, options?: any) {
            return DefaultApiFp(configuration).getTeamDetail(eventId, teamId, options)(fetch, basePath);
        },
        /**
         * Return notices
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotices(eventId: number, X_SPLATHON_API_TOKEN: string, options?: any) {
            return DefaultApiFp(configuration).listNotices(eventId, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
        /**
         * Return team list
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(eventId: number, options?: any) {
            return DefaultApiFp(configuration).listTeams(eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} eventId 
         * @param {LoginRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(eventId: number, request: LoginRequest, options?: any) {
            return DefaultApiFp(configuration).login(eventId, request, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Return event data
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEvent(eventId: number, options?: any) {
        return DefaultApiFp(this.configuration).getEvent(eventId, options)(this.fetch, this.basePath);
    }

    /**
     * Return detail team data
     * @param {number} eventId 
     * @param {number} teamId team id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTeamDetail(eventId: number, teamId: number, options?: any) {
        return DefaultApiFp(this.configuration).getTeamDetail(eventId, teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Return notices
     * @param {number} eventId 
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNotices(eventId: number, X_SPLATHON_API_TOKEN: string, options?: any) {
        return DefaultApiFp(this.configuration).listNotices(eventId, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

    /**
     * Return team list
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTeams(eventId: number, options?: any) {
        return DefaultApiFp(this.configuration).listTeams(eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} eventId 
     * @param {LoginRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(eventId: number, request: LoginRequest, options?: any) {
        return DefaultApiFp(this.configuration).login(eventId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * MatchApi - fetch parameter creator
 * @export
 */
export const MatchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * マッチの詳細を返す。スコアボードとかで使える。
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(eventId: number, matchId: number, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getMatch.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling getMatch.');
            }
            const localVarPath = `/v{eventId}/matches/{matchId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 次の試合を返す。team_id を指定した場合そのチームの、なければログインしている参加者のチームの 次のマッチをあれば返す。 team_idを指定せず参加者がチームに属して無い場合などはエラー。
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {number} [teamId] team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextMatch(eventId: number, X_SPLATHON_API_TOKEN: string, teamId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getNextMatch.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling getNextMatch.');
            }
            const localVarPath = `/v{eventId}/next-match`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a battle data in the match.
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {Battle} battle 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling updateBattle.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling updateBattle.');
            }
            // verify required parameter 'battle' is not null or undefined
            if (battle === null || battle === undefined) {
                throw new RequiredError('battle','Required parameter battle was null or undefined when calling updateBattle.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling updateBattle.');
            }
            const localVarPath = `/v{eventId}/matches/{matchId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Battle" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(battle || {}) : (battle || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchApi - functional programming interface
 * @export
 */
export const MatchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * マッチの詳細を返す。スコアボードとかで使える。
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(eventId: number, matchId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Match> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getMatch(eventId, matchId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 次の試合を返す。team_id を指定した場合そのチームの、なければログインしている参加者のチームの 次のマッチをあれば返す。 team_idを指定せず参加者がチームに属して無い場合などはエラー。
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {number} [teamId] team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextMatch(eventId: number, X_SPLATHON_API_TOKEN: string, teamId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetNextMatchResponse> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).getNextMatch(eventId, X_SPLATHON_API_TOKEN, teamId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a battle data in the match.
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {Battle} battle 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MatchApiFetchParamCreator(configuration).updateBattle(eventId, matchId, battle, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MatchApi - factory interface
 * @export
 */
export const MatchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * マッチの詳細を返す。スコアボードとかで使える。
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(eventId: number, matchId: number, options?: any) {
            return MatchApiFp(configuration).getMatch(eventId, matchId, options)(fetch, basePath);
        },
        /**
         * 次の試合を返す。team_id を指定した場合そのチームの、なければログインしている参加者のチームの 次のマッチをあれば返す。 team_idを指定せず参加者がチームに属して無い場合などはエラー。
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {number} [teamId] team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextMatch(eventId: number, X_SPLATHON_API_TOKEN: string, teamId?: number, options?: any) {
            return MatchApiFp(configuration).getNextMatch(eventId, X_SPLATHON_API_TOKEN, teamId, options)(fetch, basePath);
        },
        /**
         * Update a battle data in the match.
         * @param {number} eventId 
         * @param {number} matchId match id
         * @param {Battle} battle 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options?: any) {
            return MatchApiFp(configuration).updateBattle(eventId, matchId, battle, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
    };
};

/**
 * MatchApi - object-oriented interface
 * @export
 * @class MatchApi
 * @extends {BaseAPI}
 */
export class MatchApi extends BaseAPI {
    /**
     * マッチの詳細を返す。スコアボードとかで使える。
     * @param {number} eventId 
     * @param {number} matchId match id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getMatch(eventId: number, matchId: number, options?: any) {
        return MatchApiFp(this.configuration).getMatch(eventId, matchId, options)(this.fetch, this.basePath);
    }

    /**
     * 次の試合を返す。team_id を指定した場合そのチームの、なければログインしている参加者のチームの 次のマッチをあれば返す。 team_idを指定せず参加者がチームに属して無い場合などはエラー。
     * @param {number} eventId 
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {number} [teamId] team id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getNextMatch(eventId: number, X_SPLATHON_API_TOKEN: string, teamId?: number, options?: any) {
        return MatchApiFp(this.configuration).getNextMatch(eventId, X_SPLATHON_API_TOKEN, teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Update a battle data in the match.
     * @param {number} eventId 
     * @param {number} matchId match id
     * @param {Battle} battle 
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public updateBattle(eventId: number, matchId: number, battle: Battle, X_SPLATHON_API_TOKEN: string, options?: any) {
        return MatchApiFp(this.configuration).updateBattle(eventId, matchId, battle, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

}

/**
 * RankingApi - fetch parameter creator
 * @export
 */
export const RankingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 予選ランキングを返す。
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRanking(eventId: number, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getRanking.');
            }
            const localVarPath = `/v{eventId}/ranking`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankingApi - functional programming interface
 * @export
 */
export const RankingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 予選ランキングを返す。
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRanking(eventId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ranking> {
            const localVarFetchArgs = RankingApiFetchParamCreator(configuration).getRanking(eventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RankingApi - factory interface
 * @export
 */
export const RankingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 予選ランキングを返す。
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRanking(eventId: number, options?: any) {
            return RankingApiFp(configuration).getRanking(eventId, options)(fetch, basePath);
        },
    };
};

/**
 * RankingApi - object-oriented interface
 * @export
 * @class RankingApi
 * @extends {BaseAPI}
 */
export class RankingApi extends BaseAPI {
    /**
     * 予選ランキングを返す。
     * @param {number} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public getRanking(eventId: number, options?: any) {
        return RankingApiFp(this.configuration).getRanking(eventId, options)(this.fetch, this.basePath);
    }

}

/**
 * ReceptionApi - fetch parameter creator
 * @export
 */
export const ReceptionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 参加登録API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling completeReception.');
            }
            // verify required parameter 'splathonReceptionCode' is not null or undefined
            if (splathonReceptionCode === null || splathonReceptionCode === undefined) {
                throw new RequiredError('splathonReceptionCode','Required parameter splathonReceptionCode was null or undefined when calling completeReception.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling completeReception.');
            }
            const localVarPath = `/v{eventId}/reception/{splathonReceptionCode}/complete`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"splathonReceptionCode"}}`, encodeURIComponent(String(splathonReceptionCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 参加者情報取得API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getParticipantsDataForReception.');
            }
            // verify required parameter 'splathonReceptionCode' is not null or undefined
            if (splathonReceptionCode === null || splathonReceptionCode === undefined) {
                throw new RequiredError('splathonReceptionCode','Required parameter splathonReceptionCode was null or undefined when calling getParticipantsDataForReception.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling getParticipantsDataForReception.');
            }
            const localVarPath = `/v{eventId}/reception/{splathonReceptionCode}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"splathonReceptionCode"}}`, encodeURIComponent(String(splathonReceptionCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReception(eventId: number, X_SPLATHON_API_TOKEN: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getReception.');
            }
            // verify required parameter 'X_SPLATHON_API_TOKEN' is not null or undefined
            if (X_SPLATHON_API_TOKEN === null || X_SPLATHON_API_TOKEN === undefined) {
                throw new RequiredError('X_SPLATHON_API_TOKEN','Required parameter X_SPLATHON_API_TOKEN was null or undefined when calling getReception.');
            }
            const localVarPath = `/v{eventId}/reception`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_SPLATHON_API_TOKEN !== undefined && X_SPLATHON_API_TOKEN !== null) {
                localVarHeaderParameter['X-SPLATHON-API-TOKEN'] = String(X_SPLATHON_API_TOKEN);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReceptionApi - functional programming interface
 * @export
 */
export const ReceptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 参加登録API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ReceptionApiFetchParamCreator(configuration).completeReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 参加者情報取得API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReceptionPartcipantsDataResponse> {
            const localVarFetchArgs = ReceptionApiFetchParamCreator(configuration).getParticipantsDataForReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReception(eventId: number, X_SPLATHON_API_TOKEN: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReceptionResponse> {
            const localVarFetchArgs = ReceptionApiFetchParamCreator(configuration).getReception(eventId, X_SPLATHON_API_TOKEN, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReceptionApi - factory interface
 * @export
 */
export const ReceptionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 参加登録API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
            return ReceptionApiFp(configuration).completeReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
        /**
         * 参加者情報取得API
         * @param {number} eventId 
         * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
            return ReceptionApiFp(configuration).getParticipantsDataForReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} eventId 
         * @param {string} X_SPLATHON_API_TOKEN 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReception(eventId: number, X_SPLATHON_API_TOKEN: string, options?: any) {
            return ReceptionApiFp(configuration).getReception(eventId, X_SPLATHON_API_TOKEN, options)(fetch, basePath);
        },
    };
};

/**
 * ReceptionApi - object-oriented interface
 * @export
 * @class ReceptionApi
 * @extends {BaseAPI}
 */
export class ReceptionApi extends BaseAPI {
    /**
     * 参加登録API
     * @param {number} eventId 
     * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionApi
     */
    public completeReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
        return ReceptionApiFp(this.configuration).completeReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

    /**
     * 参加者情報取得API
     * @param {number} eventId 
     * @param {string} splathonReceptionCode ReceptionResponse.splathon.code と同じもの(たぶん内部SlackID).
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionApi
     */
    public getParticipantsDataForReception(eventId: number, splathonReceptionCode: string, X_SPLATHON_API_TOKEN: string, options?: any) {
        return ReceptionApiFp(this.configuration).getParticipantsDataForReception(eventId, splathonReceptionCode, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} eventId 
     * @param {string} X_SPLATHON_API_TOKEN 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionApi
     */
    public getReception(eventId: number, X_SPLATHON_API_TOKEN: string, options?: any) {
        return ReceptionApiFp(this.configuration).getReception(eventId, X_SPLATHON_API_TOKEN, options)(this.fetch, this.basePath);
    }

}

/**
 * ResultApi - fetch parameter creator
 * @export
 */
export const ResultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * リザルト一覧を返す。リザルトと言いつつ終了していない未来のマッチも返す。ゲスト・管理アプリ両方から使う。team_idを指定するとそのチームのみの結果が返ってくる。
         * @param {number} eventId 
         * @param {number} [teamId] team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(eventId: number, teamId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getResult.');
            }
            const localVarPath = `/v{eventId}/results`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResultApi - functional programming interface
 * @export
 */
export const ResultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * リザルト一覧を返す。リザルトと言いつつ終了していない未来のマッチも返す。ゲスト・管理アプリ両方から使う。team_idを指定するとそのチームのみの結果が返ってくる。
         * @param {number} eventId 
         * @param {number} [teamId] team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(eventId: number, teamId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Results> {
            const localVarFetchArgs = ResultApiFetchParamCreator(configuration).getResult(eventId, teamId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResultApi - factory interface
 * @export
 */
export const ResultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * リザルト一覧を返す。リザルトと言いつつ終了していない未来のマッチも返す。ゲスト・管理アプリ両方から使う。team_idを指定するとそのチームのみの結果が返ってくる。
         * @param {number} eventId 
         * @param {number} [teamId] team id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(eventId: number, teamId?: number, options?: any) {
            return ResultApiFp(configuration).getResult(eventId, teamId, options)(fetch, basePath);
        },
    };
};

/**
 * ResultApi - object-oriented interface
 * @export
 * @class ResultApi
 * @extends {BaseAPI}
 */
export class ResultApi extends BaseAPI {
    /**
     * リザルト一覧を返す。リザルトと言いつつ終了していない未来のマッチも返す。ゲスト・管理アプリ両方から使う。team_idを指定するとそのチームのみの結果が返ってくる。
     * @param {number} eventId 
     * @param {number} [teamId] team id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultApi
     */
    public getResult(eventId: number, teamId?: number, options?: any) {
        return ResultApiFp(this.configuration).getResult(eventId, teamId, options)(this.fetch, this.basePath);
    }

}

